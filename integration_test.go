package querybuilder

import (
	"context"
	"go/parser"
	"go/token"
	"os"
	"path/filepath"
	"strings"
	"testing"

	parserPkg "github.com/dchlong/querybuilder/parser"
)

// Integration tests for the complete querybuilder system

func TestQueryBuilderGenerator_EndToEnd(t *testing.T) {
	//t.Skip("Skipping integration test - requires full parser integration")
	// Create temporary directory for test files
	tempDir := filepath.Join("testdata", "tmp")
	_ = os.MkdirAll(tempDir, 0755)
	defer func() {
		_ = os.RemoveAll(tempDir)
	}()
	// Create a test Go file with struct annotations
	inputFile := filepath.Join(tempDir, "models.go")
	outputFile := filepath.Join(tempDir, "models_querybuilder.go")

	testGoCode := `package models

import "time"

//gen:querybuilder
type Product struct {
	ID        int64      ` + "`db:\"id\"`" + `
	Name      string     ` + "`db:\"name\"`" + `
	Description string     ` + "`db:\"description\"`" + `
	Price     float64    ` + "`db:\"price\"`" + `
	CreatedAt time.Time  ` + "`db:\"created_at\"`" + `
	UpdatedAt *time.Time ` + "`db:\"updated_at\"`" + `
	IsActive  bool       ` + "`db:\"is_active\"`" + `
}

// Regular struct without annotation should be ignored
type Config struct {
	Value string
}
`

	err := os.WriteFile(inputFile, []byte(testGoCode), 0644)
	if err != nil {
		t.Fatalf("Failed to create test input file: %v", err)
	}

	// Create parser (this would normally be provided by the existing system)
	structsParser := &parserPkg.Structs{}

	// Create generator
	generator := NewQueryBuilderGenerator(structsParser)

	// Generate code
	ctx := context.Background()
	err = generator.Generate(ctx, inputFile, outputFile, "")
	if err != nil {
		t.Fatalf("End-to-end generation failed: %v", err)
	}

	// Verify output file exists
	if _, err := os.Stat(outputFile); os.IsNotExist(err) {
		t.Fatal("Generated file does not exist")
	}

	// Read and verify generated content
	generatedCode, err := os.ReadFile(outputFile)
	if err != nil {
		t.Fatalf("Failed to read generated file: %v", err)
	}

	codeStr := string(generatedCode)

	// Test basic structure
	expectedElements := []string{
		"package models",
		"// Code generated by querybuilder. DO NOT EDIT.",
		"type ProductFilters struct",
		"func NewProductFilters() *ProductFilters",
		"type ProductUpdater struct",
		"func NewProductUpdater() *ProductUpdater",
		"type ProductOptions struct",
		"func NewProductOptions() *ProductOptions",
		"type ProductDBSchemaField string",
		"var ProductDBSchema = struct",
	}

	for _, element := range expectedElements {
		if !strings.Contains(codeStr, element) {
			t.Errorf("Generated code missing expected element: %s", element)
		}
	}

	// Test that Config struct is ignored (no annotation)
	unexpectedElements := []string{
		"type ConfigFilters",
		"func NewConfigFilters",
	}

	for _, element := range unexpectedElements {
		if strings.Contains(codeStr, element) {
			t.Errorf("Generated code contains unexpected element: %s", element)
		}
	}

	// Test that generated code is valid Go
	err = validateGeneratedGoCode(codeStr)
	if err != nil {
		t.Errorf("Generated code is not valid Go: %v", err)
	}
}

func TestQueryBuilderGenerator_GenerateInMemory(t *testing.T) {
	t.Skip("Skipping integration test - requires full parser integration")
	// Create temporary test file
	tempDir := filepath.Join("testdata", "tmp")
	_ = os.MkdirAll(tempDir, 0755)
	defer func() {
		_ = os.RemoveAll(tempDir)
	}()
	inputFile := filepath.Join(tempDir, "test.go")

	testGoCode := `package test

//gen:querybuilder
type Product struct {
	ID    int64  ` + "`db:\"id\"`" + `
	Name  string ` + "`db:\"name\"`" + `
	Price int    ` + "`db:\"price\"`" + `
}
`

	err := os.WriteFile(inputFile, []byte(testGoCode), 0644)
	if err != nil {
		t.Fatalf("Failed to create test file: %v", err)
	}

	// Test in-memory generation
	structsParser := &parserPkg.Structs{}
	generator := NewQueryBuilderGenerator(structsParser)

	ctx := context.Background()
	code, packageName, err := generator.GenerateInMemory(ctx, inputFile, "")
	if err != nil {
		t.Fatalf("In-memory generation failed: %v", err)
	}

	if packageName != "test" {
		t.Errorf("Package name = %v, want test", packageName)
	}

	if len(code) == 0 {
		t.Error("Generated code is empty")
	}

	codeStr := string(code)

	// Test generated content
	if !strings.Contains(codeStr, "type ProductFilters struct") {
		t.Error("Generated code missing ProductFilters")
	}

	if !strings.Contains(codeStr, "package test") {
		t.Error("Generated code missing package declaration")
	}
}

func TestQueryBuilderGenerator_WithSuffix(t *testing.T) {
	t.Skip("Skipping integration test - requires parser integration")
	tempDir := filepath.Join("testdata", "tmp")
	_ = os.MkdirAll(tempDir, 0755)
	defer func() {
		_ = os.RemoveAll(tempDir)
	}()
	inputFile := filepath.Join(tempDir, "models.go")
	outputFile := filepath.Join(tempDir, "models_v2.go")

	testGoCode := `package models

//gen:querybuilder
type Product struct {
	ID   int64  ` + "`db:\"id\"`" + `
	Name string ` + "`db:\"name\"`" + `
}
`

	err := os.WriteFile(inputFile, []byte(testGoCode), 0644)
	if err != nil {
		t.Fatalf("Failed to create test file: %v", err)
	}

	structsParser := &parserPkg.Structs{}
	generator := NewQueryBuilderGenerator(structsParser)

	ctx := context.Background()
	err = generator.Generate(ctx, inputFile, outputFile, "V2")
	if err != nil {
		t.Fatalf("Generation with suffix failed: %v", err)
	}

	generatedCode, err := os.ReadFile(outputFile)
	if err != nil {
		t.Fatalf("Failed to read generated file: %v", err)
	}

	codeStr := string(generatedCode)

	// Test that suffix is applied to struct names
	expectedWithSuffix := []string{
		"type ProductV2Filters struct",
		"func NewProductV2Filters()",
		"var ProductV2DBSchema",
	}

	for _, element := range expectedWithSuffix {
		if !strings.Contains(codeStr, element) {
			t.Errorf("Generated code with suffix missing: %s", element)
		}
	}
}

func TestQueryBuilderGenerator_MultipleAnnotationFormats(t *testing.T) {
	tempDir := filepath.Join("testdata", "tmp")
	_ = os.MkdirAll(tempDir, 0755)
	defer func() {
		_ = os.RemoveAll(tempDir)
	}()
	inputFile := filepath.Join(tempDir, "models.go")
	outputFile := filepath.Join(tempDir, "models_generated.go")

	// Test multiple annotation formats
	testGoCode := `package models

//gen:querybuilder
type Product struct {
	ID int64 ` + "`db:\"id\"`" + `
}

//@querybuilder
type Product struct {
	Name string ` + "`db:\"name\"`" + `
}

//+querybuilder
type Order struct {
	Total int ` + "`db:\"total\"`" + `
}

// No annotation - should be ignored
type Config struct {
	Value string
}
`

	err := os.WriteFile(inputFile, []byte(testGoCode), 0644)
	if err != nil {
		t.Fatalf("Failed to create test file: %v", err)
	}

	structsParser := &parserPkg.Structs{}
	generator := NewQueryBuilderGenerator(structsParser)

	ctx := context.Background()
	err = generator.Generate(ctx, inputFile, outputFile, "")
	if err != nil {
		t.Fatalf("Generation with multiple annotations failed: %v", err)
	}

	generatedCode, err := os.ReadFile(outputFile)
	if err != nil {
		t.Fatalf("Failed to read generated file: %v", err)
	}

	codeStr := string(generatedCode)

	// Test that all annotated structs are generated
	expectedStructs := []string{
		"type ProductFilters struct",
		"type ProductFilters struct",
		"type OrderFilters struct",
	}

	for _, element := range expectedStructs {
		if !strings.Contains(codeStr, element) {
			t.Errorf("Multi-annotation code missing: %s", element)
		}
	}

	// Test that non-annotated struct is ignored
	if strings.Contains(codeStr, "type ConfigFilters") {
		t.Error("Non-annotated struct should not be generated")
	}
}

func TestQueryBuilderGenerator_ErrorHandling(t *testing.T) {
	structsParser := &parserPkg.Structs{}
	generator := NewQueryBuilderGenerator(structsParser)
	ctx := context.Background()

	// Test with non-existent input file
	err := generator.Generate(ctx, "/non/existent/file.go", "/tmp/output.go", "")
	if err == nil {
		t.Error("Generate should fail with non-existent input file")
	}

	// Test with invalid output path
	tempDir := filepath.Join("testdata", "tmp")
	_ = os.MkdirAll(tempDir, 0755)
	defer func() {
		_ = os.RemoveAll(tempDir)
	}()
	inputFile := filepath.Join(tempDir, "valid.go")

	validGoCode := `package test
//gen:querybuilder
type Test struct {
	ID int ` + "`db:\"id\"`" + `
}`

	err = os.WriteFile(inputFile, []byte(validGoCode), 0644)
	if err != nil {
		t.Fatalf("Failed to create valid test file: %v", err)
	}

	// Try to write to invalid path
	err = generator.Generate(ctx, inputFile, "/root/invalid/output.go", "")
	if err == nil {
		t.Error("Generate should fail with invalid output path")
	}
}

func TestQueryBuilderGenerator_FieldTypeSupport(t *testing.T) {
	structsParser := &parserPkg.Structs{}
	generator := NewQueryBuilderGenerator(structsParser)

	// Test field type support methods
	supported := generator.GetSupportedFieldTypes()
	unsupported := generator.GetUnsupportedFieldTypes()

	expectedSupported := []string{"string", "numeric", "time", "bool", "pointer"}
	expectedUnsupported := []string{"slice", "struct", "map"}

	for _, expected := range expectedSupported {
		found := false
		for _, actual := range supported {
			if actual == expected {
				found = true
				break
			}
		}
		if !found {
			t.Errorf("Expected supported type %s not found", expected)
		}
	}

	for _, expected := range expectedUnsupported {
		found := false
		for _, actual := range unsupported {
			if actual == expected {
				found = true
				break
			}
		}
		if !found {
			t.Errorf("Expected unsupported type %s not found", expected)
		}
	}
}

// Generic type integration tests - Skip as generics are not supported
func TestQueryBuilderGenerator_GenericTypes(t *testing.T) {
	t.Skip("Generic type parameters like 'T any' are not supported by querybuilder")
}

// Helper function to validate generated Go code
func validateGeneratedGoCode(code string) error {
	fileSet := token.NewFileSet()
	_, err := parser.ParseFile(fileSet, "generated.go", code, parser.ParseComments)
	if err != nil {
		return err
	}
	return nil
}

// Test method generation and functionality
func TestQueryBuilderGenerator_GeneratedMethods(t *testing.T) {
	tempDir := filepath.Join("testdata", "tmp")
	_ = os.MkdirAll(tempDir, 0755)
	defer func() {
		_ = os.RemoveAll(tempDir)
	}()
	inputFile := filepath.Join(tempDir, "methods.go")
	outputFile := filepath.Join(tempDir, "methods_generated.go")

	testGoCode := `package methods

import "time"

//gen:querybuilder
type TestStruct struct {
	StringField  string     ` + "`db:\"string_field\"`" + `
	IntField     int        ` + "`db:\"int_field\"`" + `
	TimeField    time.Time  ` + "`db:\"time_field\"`" + `
	PtrField     *string    ` + "`db:\"ptr_field\"`" + `
	BoolField    bool       ` + "`db:\"bool_field\"`" + `
}
`

	err := os.WriteFile(inputFile, []byte(testGoCode), 0644)
	if err != nil {
		t.Fatalf("Failed to create methods test file: %v", err)
	}

	structsParser := &parserPkg.Structs{}
	generator := NewQueryBuilderGenerator(structsParser)

	ctx := context.Background()
	err = generator.Generate(ctx, inputFile, outputFile, "")
	if err != nil {
		t.Fatalf("Methods generation failed: %v", err)
	}

	generatedCode, err := os.ReadFile(outputFile)
	if err != nil {
		t.Fatalf("Failed to read generated methods file: %v", err)
	}

	codeStr := string(generatedCode)

	// Test specific method types are generated
	expectedMethods := []string{
		// String field methods
		"StringFieldEq(stringField string)",
		"StringFieldLike(stringField string)",
		"StringFieldIn(stringFields ...string)",
		// Int field methods
		"IntFieldEq(intField int)",
		"IntFieldGt(intField int)",
		"IntFieldLt(intField int)",
		// Pointer field methods (should include null checks)
		"PtrFieldEq(ptrField *string)",
		"PtrFieldIsNull()",
		"PtrFieldIsNotNull()",
		// Bool field methods (limited)
		"BoolFieldEq(boolField bool)",
		// Updater methods
		"SetStringField(stringField string)",
		"SetIntField(intField int)",
		"SetPtrField(ptrField *string)",
		// Order methods
		"OrderByStringFieldAsc()",
		"OrderByStringFieldDesc()",
		"OrderByIntFieldAsc()",
		"OrderByIntFieldDesc()",
	}

	for _, method := range expectedMethods {
		if !strings.Contains(codeStr, method) {
			t.Errorf("Generated code missing method: %s", method)
		}
	}

	// Test that generated code is syntactically correct
	err = validateGeneratedGoCode(codeStr)
	if err != nil {
		t.Errorf("Generated methods code is not valid Go: %v", err)
	}
}

func TestQueryBuilderGenerator_RealWorldScenario(t *testing.T) {
	tempDir := filepath.Join("testdata", "tmp")
	_ = os.MkdirAll(tempDir, 0755)
	defer func() {
		_ = os.RemoveAll(tempDir)
	}()
	inputFile := filepath.Join(tempDir, "realworld.go")
	outputFile := filepath.Join(tempDir, "realworld_generated.go")

	// Real-world-like struct with various field types
	testGoCode := `package realworld

import (
	"time"
	"database/sql/driver"
)

type Status int

//gen:querybuilder
type Product struct {
	ID           int64      ` + "`db:\"id\" json:\"id\"`" + `
	SKU          string     ` + "`db:\"sku\" json:\"sku\"`" + `
	Description  string     ` + "`db:\"description\" json:\"description\"`" + `
	Price        float64    ` + "`db:\"price\" json:\"price\"`" + `
	FirstName    *string    ` + "`db:\"first_name\" json:\"first_name,omitempty\"`" + `
	LastName     *string    ` + "`db:\"last_name\" json:\"last_name,omitempty\"`" + `
	DateOfBirth  *time.Time ` + "`db:\"date_of_birth\" json:\"date_of_birth,omitempty\"`" + `
	Status       Status     ` + "`db:\"status\" json:\"status\"`" + `
	IsVerified   bool       ` + "`db:\"is_verified\" json:\"is_verified\"`" + `
	CreatedAt    time.Time  ` + "`db:\"created_at\" json:\"created_at\"`" + `
	UpdatedAt    time.Time  ` + "`db:\"updated_at\" json:\"updated_at\"`" + `
	DeletedAt    *time.Time ` + "`db:\"deleted_at\" json:\"deleted_at,omitempty\"`" + `
}

//gen:querybuilder  
type Post struct {
	ID        int64      ` + "`db:\"id\"`" + `
	ProductID int64      ` + "`db:\"product_id\"`" + `
	Title     string     ` + "`db:\"title\"`" + `
	Content   string     ` + "`db:\"content\"`" + `
	Tags      []string   ` + "`db:\"tags\"`" + `      // Should not be filterable
	Metadata  map[string]interface{} ` + "`db:\"metadata\"`" + ` // Should not be filterable
	CreatedAt time.Time  ` + "`db:\"created_at\"`" + `
	UpdatedAt time.Time  ` + "`db:\"updated_at\"`" + `
}
`

	err := os.WriteFile(inputFile, []byte(testGoCode), 0644)
	if err != nil {
		t.Fatalf("Failed to create real-world test file: %v", err)
	}

	structsParser := &parserPkg.Structs{}
	generator := NewQueryBuilderGenerator(structsParser)

	ctx := context.Background()
	err = generator.Generate(ctx, inputFile, outputFile, "")
	if err != nil {
		t.Fatalf("Real-world generation failed: %v", err)
	}

	generatedCode, err := os.ReadFile(outputFile)
	if err != nil {
		t.Fatalf("Failed to read generated real-world file: %v", err)
	}

	codeStr := string(generatedCode)

	// Test comprehensive structure
	expectedStructures := []string{
		"type ProductFilters struct",
		"type ProductUpdater struct",
		"type ProductOptions struct",
		"type PostFilters struct",
		"type PostUpdater struct",
		"type PostOptions struct",
		"var ProductDBSchema",
		"var PostDBSchema",
	}

	for _, structure := range expectedStructures {
		if !strings.Contains(codeStr, structure) {
			t.Errorf("Real-world code missing structure: %s", structure)
		}
	}

	// Test that non-filterable fields (Tags, Metadata) are not in filters but are in updaters
	if strings.Contains(codeStr, "TagsEq") {
		t.Error("Slice field should not have filter methods")
	}

	if strings.Contains(codeStr, "MetadataEq") {
		t.Error("Map field should not have filter methods")
	}

	if !strings.Contains(codeStr, "SetTags") {
		t.Error("Slice field should have updater method")
	}

	if !strings.Contains(codeStr, "SetMetadata") {
		t.Error("Map field should have updater method")
	}

	// Test that generated code is valid
	err = validateGeneratedGoCode(codeStr)
	if err != nil {
		t.Errorf("Generated real-world code is not valid Go: %v", err)
	}

	t.Logf("Generated %d bytes of code for real-world scenario", len(generatedCode))
}
