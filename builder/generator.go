package builder

import (
	"bytes"
	"context"
	"fmt"
	"os"
	"path/filepath"

	"github.com/dchlong/querybuilder/domain"
	"github.com/dchlong/querybuilder/generation"
	"github.com/dchlong/querybuilder/repository"
	"github.com/dchlong/querybuilder/templates"
	"golang.org/x/tools/imports"
)

// Generator generates querybuilder code with clean architecture
type Generator struct {
	methodFactory *generation.MethodFactory
	templates     *templates.QueryBuilderTemplates
}

// NewGenerator creates a new generator instance
func NewGenerator() *Generator {
	return &Generator{
		methodFactory: generation.NewMethodFactory(),
		templates:     templates.NewQueryBuilderTemplates(),
	}
}

// GenerateCode generates querybuilder code for the given structs
func (g *Generator) GenerateCode(ctx context.Context, structs []domain.Struct, packageName string) ([]byte, error) {
	if len(structs) == 0 {
		return nil, repository.ErrNoStructsProvided
	}

	templateData := g.buildTemplateData(structs)

	var buf bytes.Buffer
	if err := g.templates.Main.Execute(&buf, templateData); err != nil {
		return nil, fmt.Errorf("%w: %w", repository.ErrTemplateExecution, err)
	}

	// Add package header
	result := g.buildPackageHeader(packageName) + buf.String()

	// Format the generated code
	formatted, err := imports.Process("", []byte(result), nil)
	if err != nil {
		if os.Getenv("DEBUG_IMPORTS_ERRORS") == "1" {
			fmt.Printf("Warning: failed to format generated code: %v\n", err)
			return []byte(result), nil
		}
		return nil, fmt.Errorf("%w: %w", repository.ErrCodeFormatting, err)
	}

	return formatted, nil
}

// GenerateFile generates querybuilder code and writes it to a file
func (g *Generator) GenerateFile(ctx context.Context, structs []domain.Struct, packageName, outputPath string) error {
	code, err := g.GenerateCode(ctx, structs, packageName)
	if err != nil {
		return fmt.Errorf("failed to generate code: %w", err)
	}

	if err := os.MkdirAll(filepath.Dir(outputPath), 0755); err != nil {
		return fmt.Errorf("%w for %s: %w", repository.ErrCreateOutputDir, outputPath, err)
	}

	if err := os.WriteFile(outputPath, code, 0644); err != nil {
		return fmt.Errorf("%w to %s: %w", repository.ErrWriteGeneratedCode, outputPath, err)
	}

	absPath, err := filepath.Abs(outputPath)
	if err != nil {
		absPath = outputPath
	}

	fmt.Printf("Generated querybuilder code: %s\n", absPath)
	return nil
}

// buildTemplateData builds the data structure for template execution
func (g *Generator) buildTemplateData(structs []domain.Struct) map[string]interface{} {
	var templateStructs []map[string]interface{}

	for _, s := range structs {
		templateStruct := map[string]interface{}{
			"Name":   s.Name,
			"Fields": s.Fields,
		}

		// Generate filter methods
		var filterMethods []domain.Method
		for _, field := range s.FilterableFields() {
			for _, op := range field.SupportedOperators() {
				method := g.methodFactory.CreateFilterMethod(s.Name, field, op)
				filterMethods = append(filterMethods, method)
			}
		}
		templateStruct["FilterMethods"] = filterMethods

		// Generate updater methods
		var updaterMethods []domain.Method
		for _, field := range s.Fields {
			method := g.methodFactory.CreateUpdaterMethod(s.Name, field)
			updaterMethods = append(updaterMethods, method)
		}
		templateStruct["UpdaterMethods"] = updaterMethods

		// Generate order methods
		var orderMethods []domain.Method
		for _, field := range s.FilterableFields() {
			// Ascending order method
			ascMethod := g.methodFactory.CreateOrderMethod(s.Name, field, true)
			orderMethods = append(orderMethods, ascMethod)

			// Descending order method
			descMethod := g.methodFactory.CreateOrderMethod(s.Name, field, false)
			orderMethods = append(orderMethods, descMethod)
		}
		templateStruct["OrderMethods"] = orderMethods

		templateStructs = append(templateStructs, templateStruct)
	}

	return map[string]interface{}{
		"Structs": templateStructs,
	}
}

// buildPackageHeader creates the package declaration and imports
func (g *Generator) buildPackageHeader(packageName string) string {
	return fmt.Sprintf(`// Code generated by querybuilder. DO NOT EDIT.

package %s

import (
	"github.com/dchlong/querybuilder/repository"
)

`, packageName)
}
